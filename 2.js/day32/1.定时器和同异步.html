<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 定时器
    // setTimeout 到达某个时间只会执行一次的定时器
    // setInterval每隔间指定的时间就会执行一次(周期性的)

    // 浏览器对于定时器的最小识别时间是不一样的 谷歌5~6ms  火狐10~12   IE 13~15

    // 定时器的返回值是一个数字，他说代表的是当前定时器在页面总的个数(第几个)
    // 定时器从第三个参数开始都是给回调函数的实参

    // let timr1 = setTimeout(() => {
    //   console.log(100);
    // },3000);
    // let timr2 = setTimeout(() => {
    //   console.log(200);
    // },4000);
    // console.log(3);
    // clearTimeout(timr1); // 在定时器到达时间之前被清除了，那定时器就不会再输出了
    // console.log(timr1,timr2); // 1 2
    // // 3 1 2 200


    // function fn() {
    //   var a = setTimeout(function () { }, 1000);
    //   console.log(a); // 2
    // }
    // var timer = setTimeout(function (a) {
    //   console.log(a);
    //   return 100;
    // }, 1000, 3);
    // clearTimeout(timer);
    // fn();
    // console.log(timer); // 1

    // console.log(1);
    // setTimeout(() => {
    //   console.log(300);
    // }, 0);
    // console.log(2);
    // console.log(3);

    // 当浏览器解析jS时，会先把所有的同步代码执行完，然后再执行异步任务队列中的代码；
    // 在代码执行的时候会有一个异步任务队列，js的主线程从上往下执行代码的时候，会一行一行的执行，
    //当执行的时候如果遇到了异步的任务，他会把这个任务放到异步任务队列中(由浏览器分配的新线程来执行)，
    //主线程在继续往下执行代码，当主线程把所有的同步代码执行完成之后，在去异步任务队列中查看有没有达到执行输出条件的异步任务，
    //如果有就拿到执行栈中进行输出，反复执行这个逻辑

    // JS 是单线程： JS同一时间只能执行一行代码；

    console.log(1);
    setTimeout(() => {
      console.log(100);       // 100
    }, 100);
    setTimeout(() => {
      console.log(200);       // 0
    }, 0);
    setTimeout(() => {
      console.log(300);       // 9
    }, 9);
    console.log(3);
    // 200 300 100


    setTimeout(function () {
    console.log(100);
  }, 20);
  console.log(300);
  console.time()
  for (var i = 0; i < 10000000; i++) {// 50ms

  }
  console.timeEnd()
  setTimeout(function () {
    console.log(400);
  }, 19);
  console.log(200);

  $.ajax({
      url: 'xxx', // 请求路径
      async: false, // 是否同异步
      type:'get', // 请求的方式
      success:(res) => {
        // 请求成功之后执行的回调
        console.log(res);
      },
      error:(res)=>{
        // 请求失败之后执行的回调
        console.log(res);
      },
      complete:()=>{
        // 不管是请求成功还是失败他都执行
        console.log(1);
      }

    });
  </script>




</body>

</html>